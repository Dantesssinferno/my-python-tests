# Привет Друзья, в данной лекции Мы рассмотрим тему наследования в Python.

# В Python классы-наследники позволяют создавать новые классы на основе существующих,
# наследуя их атрибуты и методы. Это помогает организовывать код и избегать дублирования.

# У нас имеется главный класс Alphabet, его еще называют Родительским классом,
# у которого могут быть классы Наследники, или как их еще называют - Потомки.

# Класс Alphabet отвечает за все создание и работу со всеми алфавитами,
# но предположим перед нами стоит задача создать классы для групп языков,
# например Кириллица, Латынь и т.д.  У каждого из них могут быть свои особенности,
# индивидуальные аргументы, которых может не быть в других языках - уникальные методы,
# уникальные атрибуты, которые, к примеру есть в Кириллице и их нет в Латыни.

# В данном уроке мы не будем вдаваться в изучение алфавитов и языков, я просто приведу пример,
# как создавать класс наследников,
# поэтому если я допущу ошибку в международных аббревиатурах или буквах алфавита, то прошу закрыть на это глаза.

class Alphabet:
    """Класс по созданию и работе с алфавитами"""
    def __init__(self, title, abbreviation, list_letters):
        self.title = title                  # атрибут класса
        self.abbreviation = abbreviation    # атрибут класса
        self.list_letters = list_letters    # атрибут класса
        print("Новый алфавит создан")

    def description(self):
        """Получение описания алфавита"""
        description = (f"Название данного алфавита - {self.title}, его аббревиатура - {self.abbreviation},"
                       f" список букв - {self.list_letters}")
        print(description)

    def count_letter(self):
        count = len(self.list_letters)
        print(f"Количество букв в алфавите равно: {count}")

class Cyrillic(Alphabet):
    """Язык группы Кириллица"""
    def __init__(self, title:str, abbreviation:str, list_letters:str):
        super().__init__(title, abbreviation, list_letters)
        """Указываем какие атрибуты имеет Класс-наследник"""
        self.language_group = "Cyrl"

    def description(self):
        """Получение описания алфавита"""
        description = (f"{self.title}, группа языков - {self.language_group},"
                       f"его аббревиатура - {self.abbreviation}, список букв {self.list_letters}")
        return description

    def get_language_group(self):
        """Метод возвращающий аббревиатуру языковой группы"""
        print(f"Аббревиатура языковой группы {self.language_group}")
        return self.language_group

class Latin(Alphabet):
    """Язык группы Латиница"""
    def __init__(self, title:str, abbreviation:str, list_letters:str):
        super().__init__(title, abbreviation, list_letters)
        """Указываем какие атрибуты имеет Класс-наследник"""
        self.language_group = "Lat"
        
    def description(self):
        """Получение описания алфавита"""
        description = (f"{self.title}, группа языков - {self.language_group},"
                       f"его аббревиатура - {self.abbreviation}, список букв {self.list_letters}")
        return description

russian = Cyrillic("Русский", "RUS", "абвгдеёжзийклмнопрстуфхцчшщэюяъь")
print(f"Новый алфавит называется: " + russian.description())
russian.count_letter()

serbian = Cyrillic("Сербский", "SR", "абвгдђежзијклмнњопрстћуфхцчџшыэ")
print(f"Новый алфавит называется: " + serbian.description())
serbian.count_letter()
serbian.get_language_group()

# Результат:
# Новый алфавит создан
# Название данного алфавита - Сербский, его аббревиатура - SR, список букв - абвгдђежзијклмнњопрстћуфхцчџшыэ
# Количество букв в алфавите равно: 31

# Для того, чтобы создать класс Наследник, Мы должны объявить его и в скобках указать класс Родителя
# class Cyrillic(Alphabet):

# Далее, Нам необходимо создать метод __init__, для класса Наследника
# def __init__(self, title, abbreviation, list_letters):
# super().__init__(title, abbreviation, list_letters)

# Как видите первая строка идентична с Родительским методом, но далее, нам необходимо указать функцию super().

# super() — это встроенная функция, которая используется для доступа к методам и атрибутам родительского класса
# из дочернего класса.
# Она позволяет вызывать методы родительского класса, что особенно полезно в контексте наследования.

# Обратите внимание, что Мы НЕ СОЗДАЕМ заново методы description() и count_letter(),
# они наследуются от класса Родителя, тем самым Мы сокращаем повторяемый код.

# Но что делать, если нам необходимо создать уникальный аргумент для класса Наследника,
# давайте добавим для нашего класса новый аргумент - language_group - группа языков,
# для этого нам необходимо прописать его в методе __init__,
# а так же переопределить метод description, тем самым он будет отличаться от родительского метода


# Мы прописали в метод __init__ дефолтное значение для всех экземпляров класса Cyrillic - self.language_group = "Cyrl".
# Теперь если Мы создадим два экземпляра класса: один для Родительского класса,
# второй для Наследника и вызовем метод description, то результат будет различаться,
# не смотря на идентичное название.

russian = Alphabet("Русский", "RU", "абвгдеёжзийклмнопрстуфхцчшщъыьэюя")
russian.description()

# Результат:
# Новый алфавит создан
# Название данного алфавита - Русский, его аббревиатура - RU, список букв - абвгдеёжзийклмнопрстуфхцчшщъыьэюя

serbian = Cyrillic("Сербский", "SRB", "абвгдђежзијклмнњопрстћуфхцчџшыэ")
print(f"Новый алфавит называется " + serbian.description())

# Результат:
# Новый алфавит создан
# Название данного алфавита - Сербский, группа языков - Cyrl,его аббревиатура - SR, список букв - абвгдђежзијклмнњопрстћуфхцчџшыэ

# Так же Мы можем создать уникальный метод, для класса Наследника,
# который будет доступен только в нем или в его классах Наследниках.

# Результат:
# Новый алфавит создан
# Аббревиатура языковой группы Cyrl

# Метод def get_language_group(self) доступен только для класса Cyrillic и его наследников.